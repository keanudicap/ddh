
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{float}
\usepackage{alltt}
\usepackage{algorithm}
%\usepackage[sans]{dsfont}
%\usepackage{caption}

\usepackage{url}
\urldef{\mailsa}\path|{leonid.antsfeld, daniel.harabor, toby.walsh}@nicta.com.au, adibotea@yahoo.com|
\urldef{\mailsb}\path||
\urldef{\mailsc}\path||
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Extracting Shortest Path using TRANSIT and CPDs in Video Game Maps}

% a short form should be given in case it is too long for the running head
%\titlerunning{Lecture Notes in Computer Science: Authors' Instructions}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Leonid Antsfeld \and Daniel Harabor \and Adi  Botea  \and Toby Walsh}

\institute{
UNSW, Sydney NSW 2052 Australia\\
ANU, Canberra, ACT, 0200 Australia\\
NICTA, Kensington NSW 2052 Australia\\
IBM, Dublin, Ireland\\
\vspace{0.4cm}
\hspace{-0.4cm}
\mailsa\\
}


\maketitle

\section{Introduction}
We present a new algorithm for fast extraction of the shortest path in a grid video game maps, represned as grid networks.
The presented algorithm combines strength of two well know algorithms TRANSIT~\cite{bast06} and CPD~\cite{sanka05}.
The first one is a well established technique used for very fast shortest path distance (or travel time) queries in road networks.
The later is very efficient algorithm for fast path extraction in grid networks.

\section{Related work}

\section{TRANSIT routing}\label{sec:transit}


The TRANSIT algorithm is based on a very simple intuition inspired from real-life navigation: when traveling
between two locations that are ``far away'' one must inevitably use some small set of edges that
are common to many shortest paths (highways are a natural example).
The endpoints of such edges constitute a set of so-called ``transit nodes'' for which the algorithm is named.
TRANSIT proceeds in two phases: (i) an offline precomputation phase and (ii) an online query phase.

\subsection {Offline Precomputation Phase}\label{sub:precomputation}
TRANSIT's offline precomputation phase consists of two main steps. At the first step we identify the aforesaid transit nodes
and in the second step we build a database of exact distances between every node and its associated transit nodes, as well as between all transit nodes.
We will describe each step in turn.

\subsubsection{Identifying Transit Nodes}\label{sub:determine}
TRANSIT starts by dividing an input map into a grid of equal-sized cells~
\footnote{ This grid is distinct from the one representing the input map.}.
To achieve this TRANSIT computes a bounding box for the entire map and divides this box
into $g \times g$ equal-size cells. Let $C$ denote such a cell. Further, let $I$ (Inner) and $O$ (Outer)
be squares having $C$ in the center, as depicted in Fig. \ref{fig:example} below.

\begin{figure}[H]
\centering
\includegraphics[height=5cm]{transit_example3.PNG}
\caption{Example of the TRANSIT grid; also cells and inner and outer squares. }
\label{fig:example}
\end{figure}

The size of the squares $C$, $I$ and $O$ can be arbitrary without compromising correctness. Their exact
values however will directly impact factors such as TRANSIT's preprocessing time, storage requirements and
online query times. In ~\cite{leon_daniel} we discuss how those parameters can be tuned and the tradeoff
between precomputation time, memory requirements and finally the query time.

In what follows we will compute shortest paths between nodes that resides on border of $C$ and $O$ and choose as
transit nodes one of the endpoints of the edges that cross the border of $I$. More precisely,
let $V_C$ be set of nodes as follows: for every link that has one of its endpoints inside $C$ and the other outside $C$,
$V_C$ will contain the endpoint inside $C$. Similarly, define $V_{I}$ and $V_{O}$ by considering links that cross $I$ and $O$ accordingly.
Now, the set of transit nodes for the cell $C$ is the set of nodes $v \in V_{I}$ with the property that there exists a shortest path from
some node in $V_C$ to some node in $V_{O}$ which passes through $v$. We associate every node inside $C$ with the
set of transit nodes of $C$. Next, we iterate over all cells and similarly identify transit nodes for every other cell.

\subsubsection{Computation and Storage of Distances}
\label{sub:precompute}
Once we have identified all transit nodes, we store for every node on the map, the shortest distance
from this node to all its associated transit nodes.  Recall from the previous section that every
such node $v \in V$ is associated with the set of transit nodes that were found for its cell.  In
addition we also compute and store the shortest distance from each transit node to every other
transit node.  In an undirected map it is enough to compute and store costs only in one direction.

\subsection {Local Search Radius}
\label{sub:local_radius}
TRANSIT distinguishes between two types of queries: local and global.  Two nodes for which
horizontal or vertical distance (as measured in number of cells) is greater than some \emph{local search
radius} are considered to be "far away" and the query between them is global.  We define
local search radius to be equal to the size of the inner square $I$ plus the distance from $I$ to the
outer square $O$.
This definition guarantees that for each global query two important conditions are satisfied:
 (i) the start node $src$ and destination node $dst$ are not inside the outer squares of each other
(ii) their corresponding inner squares do not overlap.
Both conditions are necessary to ensure the TRANSIT algorithm is correct and optimal.

\subsection{Online Query Phase}\label{sub:query}
For every global query from $src$ to $dst$ we fetch the transit nodes associated with cells containing
$src$ and $dst$ and choose those two that will give us a minimal cost of the combined three subpaths:
$src \rightsquigarrow T_{src}$, $T_{src} \rightsquigarrow T_{dst}$, $T_{dst} \rightsquigarrow dst$.
For all local queries the inventors of TRANSIT suggested to apply any efficient search algorithm; A* for example \cite{bast06}.
In what follows we will present a new, more efficient technique, using CPDs for dealing with local queries.

\subsection{Shortest Path Extraction}\label{sub:path_extraction}
Until now, not much work have been done on efficient path extraction using TRANSIT precomputed databases.
The intuitive and somewhat naive way would be performing a series of repeated distance queries of TRANSIT.
In the original paper the authors suggested first finding the next adjacent node to the source on the shortest path
and then iteratively applying TRANSIT query from that node to extract the full path ~\cite{bast06}.
An immediate improvement of this approach would be that we can store the next node of every precomputed
shortest path, rather than search for it.  Than we apply similar technique, by simply fetching the next adjacent node of the shortest path.
More sophisticated improvement can be achieved by observing that actually the transit node associated with destination, $T_{dst}$,
is not changing for all the sequential queries. Therefore we can exploit this fact and save time for looking for $T_{dst}$ every iteration, but 
rather reuse it.
In section ~\ref{sec:transit_cpd} we will present in details a novel, more efficient approach for the shortest path path extraction,
which is a main contribution of this paper.

\section{CPD}
CPD (aka Compressed Path Databases) precomputes and efficiently compress all pairs shortest paths as follows.
Daniel/Adi can you please add something here ?

\section{TRANSIT with CPD}\label{sec:transit_cpd}
The basic idea of our approach is to break a long shortest path (i.e. $src \rightsquigarrow dst$ is a global query)  
to number of shorter, local subpaths: $$src=T_0 \rightsquigarrow T_1 \rightsquigarrow T_2 ...\rightsquigarrow... T_{k-1} \rightsquigarrow T_{k}=dst.$$
Then we build our $src \rightsquigarrow dst$ path by sequentially extracting local subpaths $T_i \rightsquigarrow T_{i+1}, i=0...k$ from partially precomputed CPDs.
Since CPDs queries are only local, it means that we need to precompute CPDs only for pairs of nodes which are within local search radius of each other.
This is a major saving in both precomputation time and memory requirements of CPD.
\\
We start with invoking the basic TRANSIT query. From section~\ref{sub:query} we remember that every global shortest path,
(i.e. it is longer than a local search radius) is of a form: $src \rightsquigarrow T_{src} \rightsquigarrow T_{dst} \rightsquigarrow dst$. 
By definition, subpaths $src \rightsquigarrow T_{src}$ is local (i.e. no longer than a local search radius)
therefore we are applying CPDs query to extract shortest path from $src$ to $T_{src}$. Next, if $T_{src} \rightsquigarrow dst$ is a local query,
we extract this subpath from CPDs as before and we are done. If $T_{src} \rightsquigarrow dst$ is a global query, then we will repeat the above procedure 
but this time using $T_src$ as our new $srs$.
One of the advantages of this approach over the techniques mentioned in section ~\ref{sub:path_extraction} is that we advance from $src$ to $dst$ by "chunks"
of local subpaths, rather than by single link. In addition for every such "chunk" we exploit the strength of the CPD algorithm that is 
very efficient for local shortest path queries.
The pseudocode of the described algorithm as follows:
\begin{algorithm}
\begin{alltt}

   (\(T\sb{src}, T\sb{dst}) \leftarrow \) TRANSIT.query(src, dst);
   CPD.getShortestPath(src, \(T\sb{src}\));  
   while (true)                       
   \{
      if (isLocalQuery(\(T\sb{src}, dst\)) == true)
      \{
         CPD.getShortestPath(\(T\sb{src}, dst\));
         break;
      \}
      (\(T\bar{T}\sb{src}, T\sb{dst}) \leftarrow \) TRANSIT.query(\(T\sb{src}, dst\));
      CPD.getShortestPath(src, \(T\sb{src}\));  
      
   \}

\end{alltt}
\caption{Pseudo code for extracting the shortest path between \textit{src} and \textit{dst}} \label{alg:transit_cpd_pseudo}
\end{algorithm}

\section{Experimental setup}

\section{Results}

\section{Discussion}

\section{Conclusions}

bla bla~\cite{bast06}

\bibliographystyle{plain}
\bibliography{references}


\end{document}

