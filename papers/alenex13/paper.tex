
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{float}
\usepackage{alltt}
\usepackage{algorithm}
%\usepackage[sans]{dsfont}
%\usepackage{caption}

\usepackage{url}
%\urldef{\mailsa}\path|{leonid.antsfeld, daniel.harabor,
%toby.walsh}@nicta.com.au, adibotea@ie.ibm.com| \urldef{\mailsb}\path||
\urldef{\mailsc}\path||
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\usepackage{tikz}
\usepackage{tabularx,colortbl}


\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Extracting Shortest Path using TRANSIT and CPDs in Video Game Maps}

% a short form should be given in case it is too long for the running head
%\titlerunning{Lecture Notes in Computer Science: Authors' Instructions}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
%\author{Leonid Antsfeld \and Adi  Botea \and Daniel Harabor \and Toby Walsh}
\author{Paper Id: xx}

%\institute{
%UNSW, Sydney NSW 2052 Australia\\
%ANU, Canberra, ACT, 0200 Australia\\
%NICTA, Kensington NSW 2052 Australia\\
%IBM Research, Dublin, Ireland\\
%\vspace{0.4cm}
%\hspace{-0.4cm}
%\mailsa\\
%}


\maketitle

\section{Introduction}
We present a new algorithm for fast extraction of the shortest path in a grid video game maps, represned as grid networks.
The presented algorithm combines strength of two well know algorithms TRANSIT~\cite{bast06} and CPD~\cite{sanka05}.
The first one is a well established technique used for very fast shortest path distance (or travel time) queries in road networks.
The later is very efficient algorithm for fast path extraction in grid networks.

\section{Related work}

Most route planning methods rely on searching online.
On grid maps, a baseline approach uses A*~\cite{hart68}, with 
the Manhattan heuristic on 4-connected grid maps,
and the Octile heuristic on 8-connected maps.
These heuristics correspond to the true distance on a map with no obstacles.
Numerous enhancements to this baseline framework can broadly be grouped into
a few categories. Computing more informed heuristics is typically based on
pre-processing~\cite{goldberg05,bjornsson06,sturtevant09}.
Hierarchical abstraction replaces an original, flat search space with a
series of smaller searches~\cite{botea04,sturtevant05}.
Symmetry elimination can lead to strong prunning 
capabilities~\cite{harabor10,harabor11b}.
Search-based approaches can be relatively relatively slow, as the number of 
nodes visited in a search is often much larger than the actual returned path.
Furthermore, the \emph{first-move lag}, which is the time needed before
obtaining at least one move, could be large as well, given that a first move
becomes available only after a seach encounters the target.

%Real-time search without scrubbing
%Competition entries.
Thus, it is not surprising that, in recent years,
pathfinding research has included a focus on avoiding online search
as much as possible.
%kNN LRTA*~\cite{DBLP:journals/jair/BulitkoBL10}
Transit~\cite{bast06} answers distance queries very fast, in those
cases when the start and the target are sufficiently far away from each
other. However, for ``local'' queries, Transit resorts to search.
Initially applied to roadmaps, Transit was recently adapted to 
gridmaps~\cite{antsfeld12}.
Compressed Path Databases (CPDs)~\cite{botea11,DBLP:conf/socs/Botea12}
encode optimal moves for every start--target pair.
Remarkably, Transit and CPDs have complementary strengths.
Transit can be relatively slow on local queries. 
A full-scale compressed path database can face a memory bottleneck.
Thus, in this work we develop a hybrid method, which handles 
``long-distance'' parts of a path retrieval in the style of Transit.
A series of local compressed path databases, with an added size much
smaller than a full-scale CPD, efficiently handle local portions
of paths.


% Discuss Transit + highway hierarchies


\section{TRANSIT routing}\label{sec:transit}


The TRANSIT algorithm is based on a very simple intuition inspired from real-life navigation: when traveling
between two locations that are ``far away'' one must inevitably use some small set of edges that
are common to many shortest paths (highways are a natural example).
The endpoints of such edges constitute a set of so-called ``transit nodes'' for which the algorithm is named.
TRANSIT proceeds in two phases: (i) an offline precomputation phase and (ii) an online query phase.

\subsection {Offline Precomputation Phase}\label{sub:precomputation}
TRANSIT's offline precomputation phase consists of two main steps. At the first step we identify the aforesaid transit nodes
and in the second step we build a database of exact distances between every node and its associated transit nodes, as well as between all transit nodes.
We will describe each step in turn.

\subsubsection{Identifying Transit Nodes}\label{sub:determine}
TRANSIT starts by dividing an input map into a grid of equal-sized cells~
\footnote{ This grid is distinct from the one representing the input map.}.
To achieve this TRANSIT computes a bounding box for the entire map and divides this box
into $g \times g$ equal-size cells. Let $C$ denote such a cell. Further, let $I$ (Inner) and $O$ (Outer)
be squares having $C$ in the center, as depicted in Fig. \ref{fig:example} below.

\begin{figure}[H]
\centering
\includegraphics[height=5cm]{transit_example3.PNG}
\caption{Example of the TRANSIT grid; also cells and inner and outer squares. }
\label{fig:example}
\end{figure}

The size of the squares $C$, $I$ and $O$ can be arbitrary without compromising correctness. Their exact
values however will directly impact factors such as TRANSIT's preprocessing time, storage requirements and
online query times. In ~\cite{leon_daniel} we discuss how those parameters can be tuned and the tradeoff
between precomputation time, memory requirements and finally the query time.

In what follows we will compute shortest paths between nodes that resides on border of $C$ and $O$ and choose as
transit nodes one of the endpoints of the edges that cross the border of $I$. More precisely,
let $V_C$ be set of nodes as follows: for every link that has one of its endpoints inside $C$ and the other outside $C$,
$V_C$ will contain the endpoint inside $C$. Similarly, define $V_{I}$ and $V_{O}$ by considering links that cross $I$ and $O$ accordingly.
Now, the set of transit nodes for the cell $C$ is the set of nodes $v \in V_{I}$ with the property that there exists a shortest path from
some node in $V_C$ to some node in $V_{O}$ which passes through $v$. We associate every node inside $C$ with the
set of transit nodes of $C$. Next, we iterate over all cells and similarly identify transit nodes for every other cell.

\subsubsection{Computation and Storage of Distances}
\label{sub:precompute}
Once we have identified all transit nodes, we store for every node on the map, the shortest distance
from this node to all its associated transit nodes.  Recall from the previous section that every
such node $v \in V$ is associated with the set of transit nodes that were found for its cell.  In
addition we also compute and store the shortest distance from each transit node to every other
transit node.  In an undirected map it is enough to compute and store costs only in one direction.

\subsection {Local Search Radius}
\label{sub:local_radius}
TRANSIT distinguishes between two types of queries: local and global.  Two nodes for which
horizontal or vertical distance (as measured in number of cells) is greater than some \emph{local search
radius} are considered to be "far away" and the query between them is global.  We define
local search radius to be equal to the size of the inner square $I$ plus the distance from $I$ to the
outer square $O$.
This definition guarantees that for each global query two important conditions are satisfied:
 (i) the start node $src$ and destination node $dst$ are not inside the outer squares of each other
(ii) their corresponding inner squares do not overlap.
Both conditions are necessary to ensure the TRANSIT algorithm is correct and optimal.

\subsection{Online Query Phase}\label{sub:query}
For every global query from $src$ to $dst$ we fetch the transit nodes associated with cells containing
$src$ and $dst$ and choose those two that will give us a minimal cost of the combined three subpaths:
$src \rightsquigarrow T_{src}$, $T_{src} \rightsquigarrow T_{dst}$, $T_{dst} \rightsquigarrow dst$.
For all local queries the inventors of TRANSIT suggested to apply any efficient search algorithm; A* for example \cite{bast06}.
In what follows we will present a new, more efficient technique, using CPDs for dealing with local queries.

\subsection{Shortest Path Extraction}\label{sub:path_extraction}
Until now, not much work have been done on efficient path extraction using TRANSIT precomputed databases.
The intuitive and somewhat naive way would be performing a series of repeated distance queries of TRANSIT.
In the original paper the authors suggested first finding the next adjacent node to the source on the shortest path
and then iteratively applying TRANSIT query from that node to extract the full path ~\cite{bast06}.
An immediate improvement of this approach would be that we can store the next node of every precomputed
shortest path, rather than search for it.  Than we apply similar technique, by simply fetching the next adjacent node of the shortest path.
More sophisticated improvement can be achieved by observing that actually the transit node associated with destination, $T_{dst}$,
is not changing for all the sequential queries. Therefore we can exploit this fact and save time for looking for $T_{dst}$ every iteration, but 
rather reuse it.
In section ~\ref{sec:transit_cpd} we will present in details a novel, more efficient approach for the shortest path path extraction,
which is a main contribution of this paper.

\section{Compressed Path Databases}

Compressed Path Databases~\cite{botea11,DBLP:conf/socs/Botea12} are
all-pairs shortest path (APSP) data in a compressed form.
A fast retrieval of individual moves contained in a solution path, and the
optimality of moves are key strengths of CPDs. The {first-move
lag} is low, since fetching one move is independent of subsequent moves on a
path. Such strengths come at the price of a significant pre-processing time,
needed to compute all-pairs shortest path data, and a significant amount of
memory needed to store the pre-processing results.

A brief overview of CPDs is necessary to understand how the idea is integrated
into our architecture. For a more detailed description we point the reader to
the original publications~\cite{botea11,DBLP:conf/socs/Botea12}.

In the pre-processing phase, APSP data are computed with a series of independent
iterations. There is one iteration for each node $n$ on the map.
An invocation of the Dijkstra algorithm allows computing a \emph{first-move
table} $T_n$ with optimal moves $\mbox{move}(n,t)$ from $n$ towards
any reachable target $t$ on the map.\footnote{For example,
\mbox{move}(n,t) can be the id of an outgoing edge from $n$.}
The table's two-dimensional size mirrors the size of the map, 
with cell $T_n[x,y]$ storing $\mbox{move}(n,t)$ for the target $t$ with map
coordinates $(x,y)$.

Figure~\ref{figure-first-move-table} shows a first-move table for a toy map and
a given node $n$. Black cells are obstacles. Move labels are shown as arrows on
a coloured background.
For example, the cell at the bottom right is labelled
``$\rightarrow$'' because the first move from $n$ towards that cell is to the right.
Notice how move labels cluster in the figure, due to the \emph{path
coherence}~\cite{Sankaranarayanan:2005} property: on a graph such as a gridmap
or a roadmap, often, the first move from a given current location towards
\emph{any} target in a remote area is the same.

%The key intuition  
The second half of an iteration is the compression, when
a first-move table is decomposed into a list $L_n$ of disjoint
\emph{homogeneous} rectangles, with the property that all locations $t$ within a rectangle have
the same move label $\mbox{move}(n,t)$. The fewer the rectangles, the better
the compression. In the example, there are 7 homogeneous rectangles.
Part of these can be removed, without any information loss, with a
list \emph{trimming} step, which allows removing from a list
rectangles with the same move label $d$, called a default move.

\begin{figure}
\begin{center}
\input example/toymap.tex
\caption{A first-move table on a toy grid map.}
\label{figure-first-move-table}
\end{center}
\vspace{-15pt}
\end{figure}

At runtime, given a current node $n$ and a target $t$, we need to retrieve an
optimal move from $n$ towards $t$. The program searches in the list of
rectangles in $L_n$ for the rectangle that contains $t$. The move label of that rectangle is
precisely the sought optimal move. Ordering rectangles in $L_n$ decreasingly on
their size improves the move fetching time. If no rectangle containing $t$ is
found in $L_n$, it must be the case that that rectangle has been removed
as a result of trimming. Thus, the rectangle must have the move label $d$, which
is the move to return as an optimal step from $n$ towards $t$.

%Given a map, the pre-processing is done offline, being amortized over all
%queries on that map. 
The offline pre-processing can easily be paralellized, since it consists of a
series of independent iterations. Yet, the pre-processing time can be critical, for
instance in cases such as a dynamic environment, which would require to
occasionally re-compute a CPD.
Despite the ability of CPDs to compress APSP data by hundreds of times without
any information loss, their size can sometimes be a performance bottleneck,
depending on the map size, the topology, and the amount of RAM available.
Such a limitation was obvious in the recent International Grid-Based Path
Planning Competition\footnote{{\url {http://movingai.com/GPPC/index.html}}}, where Copa,
a competitor that implements CPDs, was able to run only on a subset of maps.
According to preliminary results available on the competition website, Copa
was one of the best optimal path planners, due to its fast retrieval of
individual moves.
Further reducing the memory needs and the pre-processing time
are main contributions of this work.

\section{TRANSIT with CPD}\label{sec:transit_cpd}
The basic idea of our approach is to break a long shortest path (i.e. $src \rightsquigarrow dst$ is a global query)  
to number of shorter, local subpaths: $$src=T_0 \rightsquigarrow T_1 \rightsquigarrow T_2 ...\rightsquigarrow... T_{k-1} \rightsquigarrow T_{k}=dst.$$
Then we build our $src \rightsquigarrow dst$ path by sequentially extracting local subpaths $T_i \rightsquigarrow T_{i+1}, i=0...k$ from partially precomputed CPDs.
Since CPDs queries are only local, it means that we need to precompute CPDs only for pairs of nodes which are within local search radius of each other.
This is a major saving in both precomputation time and memory requirements of CPD.
\\
We start with invoking the basic TRANSIT query. From section~\ref{sub:query} we remember that every global shortest path,
(i.e. it is longer than a local search radius) is of a form: $src \rightsquigarrow T_{src} \rightsquigarrow T_{dst} \rightsquigarrow dst$. 
By definition, subpaths $src \rightsquigarrow T_{src}$ is local (i.e. no longer than a local search radius)
therefore we are applying CPDs query to extract shortest path from $src$ to $T_{src}$. Next, if $T_{src} \rightsquigarrow dst$ is a local query,
we extract this subpath from CPDs as before and we are done. 
If $T_{src} \rightsquigarrow dst$ is a global query, then we will repeat the above procedure 
but this time using $T_{src}$ as our new $srs$. We can improve this even more, by noticing that when running sequentials quires of TRANSIT $T_{dst}$
and the distance from $T_{dst}$ to $dst$ are not changing. We can exploit this fact, by reusing $T_{dst}$. This will speed up the time complexity 
of subsequent TRANSIT queries from quadratic to linear by the number of the transit nodes.
Below we presnet the pseudocode of the described algorithm. For clarity of the idea we present the simplified version here.
\begin{algorithm}
\begin{alltt}

   (\(T\sb{src}, T\sb{dst}) \leftarrow \) TRANSIT.query(src, dst);
   CPD.getShortestPath(src, \(T\sb{src}\));  
   while (true)                       
   \{
      if (isLocalQuery(\(T\sb{src}, dst\)) == true)
      \{
         CPD.getShortestPath(\(T\sb{src}, dst\));
         break;
      \}
      (\(\bar{T}\sb{src}, \bar{T}\sb{dst}) \leftarrow \) TRANSIT.query(\(T\sb{src}, dst\));
      CPD.getShortestPath(\(T\sb{src}, \bar{T}\sb{src}\));
      \(T\sb{src} := \bar{T}\sb{src}\)  
   \}

\end{alltt}
\caption{Pseudo code for extracting the shortest path between \textit{src} and \textit{dst}} \label{alg:transit_cpd_pseudo}
\end{algorithm}

One of the advantages of this approach over the techniques mentioned in section ~\ref{sub:path_extraction} is that we advance from $src$ to $dst$ by "chunks"
of local subpaths, rather than by single link. In addition for every such "chunk" we exploit the strength of the CPD algorithm that is
very efficient for local shortest path queries. In the next section we will present a comparative analysis of this algorithm.

\section{Experimental setup}

\section{Results}

\section{Discussion}

\section{Conclusions}


\bibliographystyle{plain}
\bibliography{references}

\end{document}

