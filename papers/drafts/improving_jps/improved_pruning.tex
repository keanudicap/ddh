\section{Improved Pruning Rules}
\label{sec::pruning}
JPS distinguishes between two kinds of jump points: those that have at least
one forced neighbour and those that have none. The former can be regarded as
the grid equivalent of a visibility point: they are adjacent to at least one
obstacle, and they are on at least one optimal path between two neighbours
that are not mutually observable. If JPS prunes any of these nodes it is
entirely possible that it will not return an optimal path.  The second type of
jump points are not adjacent to any obstacle. They are simply intermediate
locations where the optimal path can change direction in order to reach the
first type of jump point or the goal.
\par
We argue that the intermediate jump points can be safely pruned without
affecting the optimality of Jump Point Search.  
Each intermediate jump point has at most three successors: the first is a jump 
point that is reachable horizontally, the second is a jump point that is reachable 
veritcally and the third is the next intermediate jump point that can be reached 
without changing direction.
When we prune an intermediate jump point we store its successors in a list and
generate them in its stead. We apply this procedure recursively to any
successors which are also intermediate jump ponts and terminate only when a
dead-end is reached.  

To see that this strategy is optimality preserving we need only observe that
for each intermediate jump point that is pruned the $g$-value of any of its
successors remains unchanged. We simply generate these nodes earlier without
first expanding the intermediate location.  The parent of each newly orphaned
successor becomes the starting location from where we initiated the jump. To
extract a concrete path we simply walk from the starting location to the
successor in a diagonal-first way: i.e. we follow the heuristic but take all
diagonal steps as early as possible. Such a path is guaranteed to be valid and
thus obstacle-free.

Our pruning strategy is applied entirely online; it does not require any
special data structures and does not store nor require any additional
information.  It allows us to jump further than we otherwise might but comes
at the cost of up to two additional open list operations for each node that we
prune. Nevertheless, we will show empirically that pruning intermediate nodes
from the search tree improves the performance of Jump Point Search.
