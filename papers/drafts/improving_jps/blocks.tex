\section{Block-based Symmetry Breaking}
\label{sec::blocks}

A first idea is to store the grid 
so as to minimise the distance between the places in memory 
that store information for two consecutive requests.  
Consider the jump point search problem 
on Figure~\ref{fig::grid} (this is only part of the grid; 
it is assumed that the grid extends very far on each of the four sides) 
where the node $N = \langle 2,4\rangle$ is expanded 
coming from node $P = \langle 1,3\rangle$.  
%More precisely, we would like to maximise the number of situations 
%where the piece of information 
%for the current request 
%is on the same block of information 
%as some very recent request.  
%Ideally the information would be in the same processor register.  
%As a consequence, no cache miss occurs for accessing this information.  

\begin{figure}[ht]
  \begin{center}
    \scalebox{0.8}{%
      \begin{tikzpicture}
        \creategrid{8}{8}
        \drawobstacle{2}{8}
        \drawobstacle{7}{3}
        \drawobstacle{6}{3}
        \draw[->] (0.7,2.7) -- (1.3,3.3);
        \draw (1.5,3.5) node {N};
        \draw (0.5,2.5) node {P};
        \draw (6.5,3.5) node {Z};
        \draw (1.5,4.5) node[red] {1};
        \draw (0.5,3.5) node[red] {2};
        \draw (2.5,3.5) node[red] {3};
        \draw (1.5,5.5) node[red] {4};
        \draw (0.5,4.5) node[red] {5};
        \draw (2.5,4.5) node[red] {6};
        \draw (1.5,6.5) node[red] {7};
        \draw (0.5,5.5) node[red] {8};
        \draw (2.5,5.5) node[red] {9};
      \end{tikzpicture}%
    }
  \end{center}
  \caption{A current search state 
    (the grid is assumed larger than the part presented).}
  \label{fig::grid}
\end{figure}

At this stage, we have to check 
whether there is a node with a forced neighbour on column $2$ from $N$ 
and similarly for row $4$ (in this instance, there is: $Z$).  
In this example, the presence of an obstacle 
will be verified (more or less) in the order given in red on the figure.  
Essentially, three columns are explored in parallel.  
A trivial representation of the grid as a one or two dimensional array
would put node $1$ far away from node $2$ in memory.  
What we propose is to put the information for node $1$ and $2$ 
in the same 32 bit- (or 64 bit-) register.  
Technically, one integer would represent the rectangle 
from $\langle 1,1\rangle$ to $\langle 4,8\rangle$.  
There are two issues here: 
\begin{itemize}
\item 
  In the example given above, we explore the column 2, 
  and the integer contains the information in columns 1--4 
  (which is convenient).  
  If we are to explore the column 4, 
  then we need information from columns 3, 4, and 5, 
  hence from two different integers.  
  We could have two copies of the grid: 
  a rectangle from $\langle 1,1\rangle$ to $\langle 4,8\rangle$ 
  and a rectangle from from $\langle 3,1\rangle$ to $\langle 6,8\rangle$.  
\item 
  We want the rectangle to be long and not large, 
  so that we can search far without loading a new rectangle.  
  We might also want another copy of the grid for when we explore rows
  rather than columns.
\end{itemize}
A number of these possibilities require increased memory overheads. 
We would need experiments to decide the best option. For example
For example, how large should we make our rectangles? How much benefit can we
derive from storing two copies of the map, one ordered by rows and the other
orderd by columns? Does overlapping rectangles yield a substantial
performance gain over the above?
%\subsection{Empty Blocks}
Consider again the example given in Figure  ~\ref{fig::grid}.  
Assume now that there is no obstacle in $\langle 2,8\rangle$.  
Rather than testing every grid node individually, 
we could immediately (i.e., virtually for free) determine 
that the integer representing the rectangle 
evaluates to $0$, i.e., there is no obstacle.  
Because there is no obstacle in the rectangle, 
we can immediately jump to the next rectangle.  
\section{Identifying Jump Point in Non Empty Blocks}
The idea here is to use bitwise operators
to manipulate a bunch of nodes together.  
Consider the left-to-right exploration of row $4$.  
The following bytes (bytes are used for simplicity; 
the idea generalises to blocks of any size, e.g., integers) 
represent the obstacles in rows 5, 4, and 3.  

\begin{center}
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
    \hline
    0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\
    \hline
  \end{tabular}
\end{center}

We want to identify (i) the positions $x$ on row~4 which are traversable and can
be reached without hitting an obstacle and (ii) the positions $x$ which have
forced neighbours at locations $x-1$ in rows $3$ or $5$.
For instance, to decide which positions $x$ from row 3 
are not obstacles, you simplify need to do a bitwise negation: 
\begin{center}
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    1 & 1 & 1 & 1 & 1 & 0 & 0 & 1 \\
    \hline
  \end{tabular}
\end{center}
To decide the positions $x$ on row 3 
such that there is an obstacle on position $x-1$, 
you simplify need to do a shift: 
\begin{center}
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\
    \hline
  \end{tabular}
\end{center}
To decide the positions $x$ on row 3 
that satisfy both property defined above, 
you simplify need to do a bitwise \& operation 
on the two last bytes: 
\begin{center}
  \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\
    \hline
  \end{tabular}
\end{center}

Deciding whether the first jump point is  reached
before an obstacle is hit on the current row 
could probably be tested by a $\le$ operation or via
some bit masking mechanism.
Clearly, details need to be worked out here but the problem
is cute and looks fun to solve.
