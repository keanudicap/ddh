\begin{figure*}[tb]
       \label{fig:preproc}
       \begin{center}
%		   \includegraphics[width=0.95\columnwidth]
%		{diagrams/preproc.png}
         \scalebox{.8}{\input{diagrams/preproc.tex}}
       \end{center}
%	\vspace{-3pt}
       \caption{(a) A jump point is computed in place of each grid neighbour of node $x$.
		(b) When jumping from $x$ to $y$ we may cross the row or column of the target $t$ (here, both). 
To avoid jumping over $t$ we insert an intermediate successor $y'$ on the row or column of $t$ (whichever is closest to $x$).}
\end{figure*}

\section{Preprocessing}
\label{sec::preprocessing}

While the previous section has shown 
that identification of jump point can be accelerated, 
it is still possible to improve further the performance 
by preprocessing the position of the jump point 
from each position in the grid.  

Remember that a jump point 
is a point in the current direction of travel 
that satisfies one of these conditions: 
\begin{itemize}
\item 
  the point has a forced neighbour; 
\item 
  the point is the target; or 
\item 
  the current move is diagonal 
  and there is a straight-path from this point to a jump point.  
\end{itemize}
For any node, 
the jump points of the first type and some of the last type 
can be identified a priori (before the target is known); 
they are stored in an adjacency list data structure 
and retrieved in constant time at runtime.  
The jump points of the second type and the rest of those of the last type 
cannot be found at pre-process, 
but it is easy to identify them at runtime: 
one just needs to check whether the current jump 
crosses the row or column of the target.  
Notice however that the jump must be attempted 
even if it leads to an obstacle.  

This is illustrated on Figure~\ref{fig:preproc}.  
The left side of the figure shows the precomputed jump points 
for node $N = \langle 4,5\rangle$.  
Nodes $3$---$5$ are typical examples of jump points.  
The other nodes, however, would normally be discarded 
at runtime because they lead to dead-ends; 
those nodes are called \emph{sterile jump points}.  

Consider now the grid on the right, when $T$ is the target node.  
Travelling South-East, the jump point from $N$ is $J$.  
However $J$ was not identified at preprocessing time 
because $T$ was unknown.  
Instead, the sterile jump point $S$ is recorded in the database.  
Normally $S$ would be discarded at runtime 
because it is a deadend.  
Sterile jump points are kept in the database though, 
and a cheap test however demonstrates that the jump $N\rightarrow S$ 
crosses both the row and the column of $T$.  
Node $J$ is identified as the first intersection node 
and is therefore dynamically introduced as the jump point from $N$.  

TALK ABOUT PREPROCESS AND HOW CHEAP IT IS.  
MAYBE PROVIDE EVIDENCE OF THAT.  
DISCUSS THE SIZE OF THE DATA STRUCTURE?

\subsection*{Properties}
JPS+ requires an offline pre-processing step that has quadratic time complexity
and linear space requirements w.r.t the number of nodes in the grid.
Preprocessing eliminates entirely the need to search for jump
points but it has two disadvantages (i) jump points need to be recomputed
if the map changes (some local repair seems enough) and (ii) it introduces 
a substantive memory overhead: we need to keep for each node 8 distinct identifiers. 
The overhead can be as large as $4\times8$ bytes per node. 
