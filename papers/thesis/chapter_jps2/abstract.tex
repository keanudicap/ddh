\chapter{Improving Jump Point Search}
\label{cha::jps2}
In the previous chapter we described Jump Point Search (JPS): an effective
technique for for identifying and eliminating path symmetries on-the-fly.  JPS
can be described as the combination of A* search with two simple
neighbour-pruning rules. When applied recursively these rules can improve the
performance of optimal grid-based pathfinding by an order of magnitude and
more -- all without any pre-processing and without the introduction of any
memory overheads. 

In this chapter give several online and offline optimisation techniques to 
further improve the performance of Jump Point Search. In particular:
\begin{itemize}
\item We give a new and more efficient procedure for online symmetry breaking. 
We describe how an efficient bitwise encoding of the grid that
allows us to manipulate ``blocks'' of nodes.
We show that using such an encoding it is possible
for JPS to effectively break symmetries for many nodes at the same time -- 
rather than considering each node individually.
\item We describe a new variant of JPS which uses offline pre-processing to 
further speed up pathfinding search. Our approach exploits the fact that many
jump points are goal-independent. We show that it is possible to pre-compute 
and store all such jump points for every node on the map.
\item We enhance the pruning rules of JPS by showing that many of the nodes
which it currently expands are simply intermediary locations that can be
safely ignored. These enhanced rules can be easily combined with either
of the previously described contributions.
\end{itemize}

We run a large number of experiments on three benchmark domains taken from real
computer games. We find that our  enhancements can significantly improve JPS performance by
anywhere from several factors  (in the online case) to over one order of magnitude
(using pre-processing). Each improvement is complete and optimal
and requires either no time and memory overhead or only a small amount.
Moreover, we demonstrate that our improvements are competitive with and often 
faster than two very recent state-of-the-art pathfinding algorithms from the literature.

The contributions in this chapter have previous appeared in~\citep{haraborG14}

