\section{Introduction}
\label{cha::jps2::introduction}
The efficiency of Jump Point Search depends on being able to quickly scan many nodes
from the underlying grid map in order to identify successor nodes (i.e. jump points).
One the one hand such a procedure can typically save many unnecessary
node expansions. On the other hand the same operation proceeds in a 
step-by-step manner and it can scan the same node multiple times during 
a single search. 
Consider Table~\ref{table::jps2::bottleneck}, where we give a comparative
breakdown of how JPS and A{*} spend their time during search.
The results are obtained by running
a large set of standard instances on three realistic game benchmarks
that appeared in the 2012 Grid-based Path Planning Competition. Observe that
JPS spends $\sim$90\% of its time generating successors (cf. $\sim$40\% for
A{*}) instead of manipulating nodes on the open and closed lists -- i.e.
searching.

In this chapter we propose a number of ideas that to improve the
performance of Jump Point Search. We focus particularly on: (i) 
more efficient online symmetry breaking that reduces the time spent scanning the grid; 
(ii) pre-computation strategies for breaking symmetries offline.
(iii) more effective online pruning strategies that avoid expanding some jump
points; 
We evaluate our ideas on three realistic grid-based benchmarks and
find that our enhancements can improve the performance of Jump Point Search
by anywhere from several factors to over one order of magnitude. 
%In the case of 
%our first two contributions, we achieve this without compromising optimality, without
%preprocessing and without any memory overheads. In the case of our third
%contribution, some preprocessing and additional memory are introduced 
%in order to increase the performance of search.

\input{chapter_jps2/table_bottleneck}

%\newpage
