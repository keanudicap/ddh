\section{Memory Requirements and Dynamic Environments}
\label{cha::rsr::memory}
\textbf{Memory Requirements: }
In the most straightforward implementation, RSR requires storing the id of the
parent rectangle for each node in the original grid. 
This equates to an $O(|V|)$ memory overhead, where $V$ is the set of nodes
in the underlying graph.
Due to the simple geometric nature of empty rectangles, the set of macro
edges associated with each perimeter node can be computed on-the-fly in
constant time. 
\newline \noindent
\textbf{Dynamic Environments: }
In many application areas, most notably video games, the assumption of a static 
environment is sometimes unreasonable.
For example: obstacles may appear on the grid or existing obstacles may be
destroyed as the game progresses.
In such cases the underlying graph representing the world must be updated.
If a new obstacle appears, or an existing one is destroyed,
we can simply invalidate the affected rectangles and recompute new ones.
%The repair operation must be very fast as most such applications run in real
%time. As we will show, RSR appears particularly well suited for this task.

