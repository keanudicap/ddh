\section{Other Search Enhancements}
\label{cha::lit::enhancements}

\subsection{Abstraction Techniques}
\label{cha::lit::enhancements::abstraction}
In cases where optimality is not required, hierarchical pathfinding methods
are pervasive.  They improve performance by decomposing the
search space, usually offline, into a much smaller approximation.  Algorithms
of this type, such as HPA*~\cite{botea04}, are  fast and
memory-efficient but also suboptimal.

Algorithms of this type are fast and use little memory but compute paths which are usually not
optimal and must be refined via further search. Typical examples: HPA*~\cite{botea04} and
MM-Abstraction~\cite{sturtevant07}.

Other Abstractions:
\begin{enumerate}
\item{Exact: Transit, Highway Hierarchies, Contraction Hierarchies}
\end{enumerate}

\section{Improved Heuristics}
\label{cha::lit::enhancements::heuristics}
Algorithms of this type usually pre-compute and store distances between key pairs of locations
in the environment. Though fast and optimal, such methods can incur signficant
memory overheads which is often undesirable. Typical examples: Landmarks~\cite{goldberg05} and
True Distance Heuristics~\cite{sturtevant09}.

Other Heuristics:
\begin{enumerate}
\item{Weighted heuristics}
\item{Dead-end and Gateway Heuristic}
\item{Differential Heuristics}
\item{AAAI-11 thing on one-dimensional heuristic?}
\end{enumerate}

\section{Search Space Pruning}
\label{cha::lit::enhancements::pruning}
Algorithms of this type usually aim to identify areas on the map that do not need to be explored in
order to reach the goal optimally. Though not as fast as abstraction or memory
heuristics, such methods usually have low memory requirements and can improve
pathfinding performance by several factors. Typical examples: Dead-end Heuristic~\cite{bjornsson06}
Swamps~\cite{pochter09} and the Portal Heuristic~\cite{goldenberg10}.

The \emph{dead-end heuristic} \cite{bjornsson06} and \emph{Swamps} \cite{pochter10}
are two similar pruning techniques related to our work.
Both decompose grid maps into a series of adjacent areas. Later, this decomposition
is used to identify areas not relevant to optimally solving a particular
pathfinding instance.
This objective is similar yet orthogonal to our work where
the aim is to reduce the effort required to explore any given area in the search
space.

A different method for pruning the search space is to identify \emph{dead} and
\emph{redundant} cells~\cite{sturtevant10b}.  Developed in the context of
learning-based heuristic search, this method speeds up search only after running
multiple iterations of an iterative deepening algorithm.  Further, the
identification of redundant cells requires additional memory overheads which
jump points do not have.

\emph{Fast expansion}~\cite{sun09} is another related work that speeds up
optimal A* search. It avoids unnecessary open list operations when it finds a
successor node just as good (or better) than the best node in the open list.
Jump points are a similar yet fundamentally different idea: they allow us to
identify large sets of nodes that would be ordinarily expanded but which can be
skipped entirely.

\section{Database Driven Approaches}
\label{cha::lit::enhancements::db}

\begin{enumerate}
\item{SILC and CPDs}
\item{Block A*}
\end{enumerate}

