\section{Types of Search Graphs}
\label{cha::lit::graphs}
Many approaches exist for creating a search graph from a given input map; we
discuss a broad range of popular methods in the remainder of this section.
\\ \newline
Should mention~\citep{yap02} and (see Cindy's thesis for other ref) which 
compare different types of representations. Also Tozour's Search Space Representations
article.
Maybe a section on choosing which one?

\subsection{Grid Maps}
\label{cha::lit::graphs::grid}
A grid map is a tesselation of unit squares, often called tiles, which is
applied over a planar input map. Each tile has up to eight adjacent neighbours
and is marked as traversable or non-traversable depending on whether or not it
intersects any obstacles.  Agents are often modeled as unit-size entities that
occupy a single tile and move from the centre of one traversable tile to the
next.  
An alternative approach is to model agents as point-size entities that occupy 
the intersections of the grid and which travel in straight steps along the
explicit edges of grid and diagonally through tile interiors.
In both cases straight steps incur a cost of 1. Diagonal steps, if permitted, 
incur a cost of $\sqrt{2}$.  When diagonal moves are not permitted the grid map 
is said to be \emph{4-connected}; otherwise it is \emph{8-connected}.  

Grid maps are popular for several reasons: (i) they are simple to understand 
and simple to apply (ii) they can be represented as a matrix of bits and stored
efficiently (iii) individual nodes can be updated or queried in constant time.
One significant disadvantage of grid maps is their fixed resolution. In many cases 
grids are too coarse to accurately model the underlying input map. Increasing the
number of tiles is not always possible: there is always a corresponding increase in
memory requirements and searching in a larger grid often makes pathfinding more 
challenging.
Another disadvantage of grid maps is that they produce paths which are
constrained to the points of the grid. Such paths are not only aesthetically
displeasing but they can also be longer than stricictly necessary and may
require post-processing to ``smooth'' them.

\subsection{Navigation Meshes}
\label{cha::lit::graphs::nav}
A navigation mesh can be described as a low-fidelity model of an input map. 
Typically comprising a set of convex adjacent polygons, navigations meshes are
often used in computer games to represent walkable and non-walkable surfaces in
two and three dimensions~\citep{snook00,tozour02}.
There are many approaches for constructing navigation meshes.
One recent technique triangulates the input map~\citep{demyen07,kallmann10}.  
Another decomposes the map into voxels which are then manipulated in order to construct a 
mesh of walkable polygons. 
Recursive spatial indexing algorithms can also be applied to produce navigation meshes. 
Quad Trees~\citep{finkel74,samet85}, for example, can be used to decompose an input
map into a set of adjacent obstacle-free rectangular regions. 

Meshes are popular because they are representationally complete and often more
memory efficient than other search graphs e.g. grid maps. Another advantage is
flexibility. For example, meshes can be hand-edited by game developers needing
fine grained control over agent navigation. Meshes are also well understood by 
those in the game development industry and tools exist to aid in their creation; 
e.g. \textsc{NavPower} and \textsc{Recast Navigation}. Disadvantages include: 
\begin{itemize}
\item Meshes need to be recomputed/repaired if the environment changes.
\item Computed paths often need to be smoothed or otherwise post-processed.
\item Locating particular polygons involves search. In the case 
of Quad Trees each such operation takes logarithmic time. In other cases
a linear search may be required.
\end{itemize}


\subsection{Roadmaps}
\label{cha::lit::graphs::road}
A roadmap is a set of connected points that are drawn from a given input map.
Conceptually similar to \emph{road networks}, which model automotive
transportation systems, roadmaps are used to solve high dimensional pathfinding
problems in the area of robotics.  Many variants exist. The Probabilistic
Roadmap (PRM)~\citep{kavraki94}, for example,
 is created by randomly sampling a configuration space (i.e. the input map) in
order to build a connected graph. Another approach, known as the Reachability
Roadmap (RRM)~\citep{geraerts05} applies a grid tesselation in the first
instance and then chooses points from the grid.  Voronoi Diagrams~\citep{aurenhammer91}
can also be regarded as a type of roadmap. In this case a network of edges is constructed
which are all equi-distant from the two closest obstacles; the nodes of the network are 
found at the intersections of these edges.

Roadmaps are advantageous because they are an effective means of discretising
large multi-dimensional search spaces into small graphs that can be searched
efficiently. For example: using a roadmap any pathfinding problem can be
factored into three smaller subproblems: find a path from each of the start and
target configuration to a point on the roadmap then search for a path on the
roadmap that connects these two points. Disadvantages include:
\begin{itemize}
\item{Some types of roadmaps are not complete. For example, when using a PRM the probability of 
a path being found, if one exists, increases with the number  of samped points~\citep{barraquand97}. 
By comparison RRMs have stronger guarantees but their applicability
is limited to pathfinding in two and three dimensions.}
\item{Roadmaps are applicable only in static environments. The introduction of
new obstacles or changes to the placement of existing obstacles typically require 
the roadmap to be re-computed or repaired. A one-shot variation of the roadmap idea has been
developed to address this limitation~\citep{lavalle98} but it is not as reliable
as static roadmaps.}
\item{Roadmaps compute only approximately shortest paths and they assume a single 
robot type (i.e. they are normally not reusable).}
\end{itemize}

\subsection{Shortest Path Maps}
\label{cha::lit::graphs::spm}
A Shortest Path Map (SPM)~\citep{mitchell87,mitchell97}, is a tree whose nodes
form a shortest path cover of an input map.  The nodes of the tree are regions
that are computed and organised with respect to a single source point. Each
point interior to a region can be reached from the source by following a path in
the SPM that is fixed.
% Associated with each region is a root
%which is the last common vertex on the shortest path from the source to any
%point inside the region.  To extract a shortest path, from the source to any
%target point, one simply walks from the target point, which is a leaf, to the
%top of the tree, which is the source, by moving from r

Developed by practitioners working in the area of Computational Geometry, SPMs
are highly efficient data structures: they can facilitate the extraction
of a shortest path from the source to any point on the map in just logarithmic time.
Their primary disadvantage is that they are limited to queries originating at
a single fixed source. Each time the source changes the SPM must be recomputed and
each such operation requires $O(n\log_2{n})$ space and time. 
Another disadvantage is that techniques developed for computing SPMs are complex 
and difficult to implement in practice~\citep{surazhsky05}. 

\subsection{Visibility Graphs}
\label{cha::lit::graphs::vis}
A visibility graph~\citep{lozanoperez79} is a model of an input map based on
line-of-sight.  In the canonical case each vertex in a planar environment
becomes a node in a graph. Edges are then added between any pair of nodes that
are visible from one another.  Often employed in robot
motion planning and computer games, visibility graphs are popular due to their 
simplicity and ability to provide strong guarantees including completeness and 
(depending on the search strategy at hand) Euclidean optimality. Disadvantages 
include:
\begin{itemize}
\item Visibility graphs can be very large; in the worst case every
vertex is visibile from every other vertex and a quadratic number
of edges is required. Tangent Graphs~\citep{liu92} and Silhouette Zones~\citep{young01b}
are two variant approaches that address this shortcoming in many practical
cases but their memory requirements remain worst-case quadratic.
\item Visibility graphs are static models and must be recomputed or 
repaired if the environment changes.
\end{itemize}

