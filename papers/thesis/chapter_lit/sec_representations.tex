\section{Discrete Search Graphs}
\label{cha::lit::graphs}
Pathfinding is the problem of navigating between an arbitrary pair of points on
a given \emph{input map}.  In the most common setting input maps are
two-dimensional Euclidean (i.e. flat) or three-dimensional Geodesic (i.e. curved) 
spaces. They can take the form of a \emph{spatial network} (i.e. a set of
connected points) or they can be given as a collection of traversable and
non-traversable polytopes; the latter often being called obstacles.

In order to find an obstacle-free path from one point to another practitioners
begin by constructing from the input map a data structure $G = (V, E)$
known as a \emph{search graph}.  Here $V$ is a set of permissible locations that
an agent can occupy; these are often referred to as the nodes or \emph{vertices}
of the graph.  Meanwhile $E$ is the set of \emph{edges} that connect adjacent
vertices.  Edges can be thought of as roads or corridors that an agent can
travel along or actions that can be executed in order to transition the agent
from one location to another.
The cost associated with each such move is called the \emph{edge weight}.
Weights often represent distance travelled but they could stand for other types
of metrics as well e.g. travel time or fuel consumption.  When the cost of
moving between two vertices $a$ and $b$ can differ to the cost of moving from $b$ to
$a$ the graph is said to be \emph{directed}.  When this is not the case, the
graph is said to be \emph{undirected}.  

Search graphs can be explicit, in which case all vertices and edges are
enumerated apriori, or they can be implicit, in which case the graph is
gradually built during search. Explicit graphs arise in many settings including
computer games~\citep{davis00,tozour02,champandard09}, 
routing~\citep{sanders05,goldberg06} and robot motion
planning~\citep{latombe91,choset05}.  Implicit graphs appear in higher
dimensional pathfinding settings~\citep{lavalle98,bohlin00} and related
application areas such as AI Planning~\citep{russel03}.  

Many approaches exist for creating a search graph from a given input map; we
discuss a broad range of popular methods in the remainder of this section.

Should mention~\citep{yap02} and (see Cindy's thesis for other ref) which 
compare different types of representations. Also Tozour's Search Space Representations
article.
Maybe a section on choosing which one?

\subsection{Grid Maps}
\label{cha::lit::graphs::grid}
A grid map is a tesselation of unit squares, often called tiles, which is
applied over a planar input map. Each tile has up to eight adjacent neighbours
and is marked as traversable or non-traversable depending on whether or not it
intersects any obstacles.  Agents are often modeled as unit-size entities that
occupy a single tile and move from the centre of one traversable tile to the
next.  
An alternative approach is to model agents as point-size entities that occupy 
the intersections of the grid and which travel in straight steps along the
explicit edges of grid and diagonally through tile interiors.
In both cases straight steps incur a cost of 1. Diagonal steps, if permitted, 
incur a cost of $\sqrt{2}$.  When diagonal moves are not permitted the grid map 
is said to be \emph{4-connected}; otherwise it is \emph{8-connected}.  

Grid maps are popular for several reasons: (i) they are simple to understand 
and simple to apply (ii) they can be represented as a matrix of bits and stored
efficiently (iii) individual nodes can be updated or queried in constant time.
One significant disadvantage of grid maps is their fixed resolution. In many cases 
grids are too coarse to accurately model the underlying input map. Increasing the
number of tiles is not always possible: there is always a corresponding increase in
memory requirements and searching in a larger grid often makes pathfinding more 
challenging.
Another disadvantage of grid maps is that they produce paths which are
constrained to the points of the grid. Such paths are not only aesthetically
displeasing but they can also be longer than stricictly necessary and may
require post-processing to ``smooth'' them.

\subsection{Roadmaps}
\label{cha::lit::graphs::road}
A roadmap~\citep{kavraki94} is a set of connected points that are drawn from a given
input map. Conceptually similar to \emph{road networks}, which model automotive
transportation systems, roadmaps are used to solve high dimensional pathfinding 
problems in the area of robotics.
Constructing a roadmap typically involves random sampling of a configuration
space (i.e. the input map).
The idea is to find configurations of a robot that do not intersect any obstacles
and to connect, in a graph, any two configurations where the robot can transition
from one to the other without intersecting any obstacles.

Roadmaps are advantageous because they are an effective means of discretising
large multi-dimensional search spaces into small graphs that can be searched
efficiently. For example: using a roadmap any pathfinding problem can be
factored into three smaller subproblems: find a path from each of the start and
target configuration to a point on the roadmap then search for a path on the
roadmap that connects these two points. Disadvantages include:
\begin{itemize}
\item{Roadmaps are only probabilistically complete~\citep{barraquand97}. 
This means that the probability of a path being found, if one exists, 
increases with the number of sampled points.
Other types of roadmaps~\citep{geraerts05} have stronger guarantees but their
applicability is limited to pathfinding in two and three dimensions.}
\item{Roadmaps are applicable only in static environments. The introduction of
new obstacles or changes to the placement of existing obstacles typically require 
the roadmap to be re-computed. A one-shot variation of the roadmap idea has been
developed to address this limitation~\citep{lavalle98} but it is not as reliable
as static roadmaps.}
\item{Roadmaps compute only approximately shortest paths and they assume a single 
robot type (i.e. they are normally not reusable).}
\end{itemize}

\subsection{Navigation Meshes}
\label{cha::lit::graphs::nav}
A navigation mesh can be described as a low-fidelity wire-frame model of an input
map. Commonly used in computer games~\citep{snook00,tozour02}, navigation meshes are a
popular technique for representing walkable and non-walkable surfaces in two but
more often three-dimensional space.  One approach for creating a navigation mesh
involves directly triangulating the input map~\citep{demyen07,kallmann10}.  
Another procedure~\cite{mononen09} uses voxel decomposition in order to construct a 
mesh of convex polygons that can be used for pathfinding.

Navigation meshes are popular because they are complete and they are often more
memory efficient than other search graphs e.g. grid maps. Another advantage is
flexibility; e.g., meshes can often be hand-edited by level designers needing
fine grained control over agent navigation. Meshes are also well understood by 
game developers and industry standard tools exist to aid their creation; 
e.g. \textsc{NavPower} and \textsc{Recast Navigation}. Disadvantages include: 
\begin{itemize}
\item Meshes need to be recomputed/repaired if the environment changes.
\item Computed paths may need to be post-processed.
\item Locating particular polygons can involve linear search.
\end{itemize}

\subsection{Visibility Graphs}
\label{cha::lit::graphs::vis}

\subsection{Voronoi Diagrams}
\label{cha::lit::graphs::voronoi}

