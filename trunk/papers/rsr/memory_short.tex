\section{Memory Requirements and Dynamic Maps}
\label{sec:memory}
\textbf{Memory Requirements: }
In the most straightforward implementation, RSR requires storing only the id of the
parent rectangle for each node in the original grid. 
Given the simple geometric nature of empty rectangles, the set of macro-edges
for each perimeter node can be computed on-the-fly in constant time. 
This equates to an $O(|V|)$ memory overhead, where $V$ is the set of nodes
in the underlying graph.
\newline \noindent
\textbf{Dynamic Environments: }
In many application areas, most notably video games, the assumption of a static 
environment is sometimes unreasonable.
For example: obstacles may appear on the grid or existing obstacles may be
destroyed as the game progresses.
In such cases the underlying graph representing the world must be updated.
If a new obstacle appears, or an existing one is destroyed,
we can simply invalidate the affected rectangles and recompute new ones.
The repair operation must be very fast as most such applications run in real
time. As we will show, RSR appears particularly well suited for this task.
