\section{Conclusion}
\label{sec::conclusion}

We study several techniques for improving Jump Point Search (JPS).  
The first improvement builds on the property 
that JPS spends a large time searching for long-distance straight paths, 
and uses the bit representation of the map to consider many nodes at a time.  
The second improvement, based on the property 
that most rules for computing jump points are goal-independent, 
is a pre-processing strategy 
which computes and stores jump point successors for every node on the map.  
Our third improvement is a pruning strategy 
that avoids many expansion operations.  

There are several interesting directions for further work. One possibility is
stronger pruning rules that will allow us to jump over some of the remaining
nodes in the graph. For example: we might consider %combining JPS with Fast
%Expansion~\cite{sun09}; i.e. we 
pruning a node $n$ if all of its successors have
an $f$-value that is not larger than $f(n)$. A stronger variant of this idea
is to keep jumping as long as we are heading in the same direction as when we
reached $n$ --- or in a new direction which is a component of the one used to
reach $n$. It is likely that this procedure will increase the branching factor
at $n$ but we posit that fewer node expansions will be required overall because
we do not need to stop each time the path turns due to an obstacle.

Combinations of JPS with existing grid-based speedup 
techniques appears to be another fruitful direction for further research. 
A number of well-known speedup techniques, both optimal and sub-optimal,
work by limiting the scope of grid search to a corridor of nodes relevant
for the instance at hand; e.g. Swamps~\cite{pochter10}, HPA{*}~\cite{botea04}
or any number of pruning-based heuristics e.g.~\cite{bjornsson05,goldenberg10}.
JPS can be trivially combined with such approaches to further speed up search.

One strength of the JPS family 
is that it performs very well even online.  
We have shown however that pre-computed jump points 
accelerate significantly the search.  
It is possible to combine both approaches, 
by populating the jump point database 
as they are discovered online.  
We want to apply this feature in dynamic environments 
where obstacles appear or disappear, 
immediately rendering any pre-processed information obsolete.  

% EOF
