\begin{figure}[tb]
       \begin{center}
		   \includegraphics[width=0.95\columnwidth, trim = 0mm 0mm 0mm 0mm]
			{diagrams/speedup.pdf}
       \end{center}
\caption{Average search time speedup and average node expansion speedup for our three benchmark problem sets. In each case we measure relative improvement vs. A* 
across a range of instances. Higher is always better. NB: Algorithms JPS (B+P) and JPS+ (P) always expand the same number of nodes. }
\label{fig::speedup}
\end{figure}

\section{Results}
\label{sec::results}

We analyse the impact on search performance for each of our three optimisation techniques:
block-based jumping, denoted by JPS (B); improved pruning rules, denoted by JPS (P) and 
pre-processed jump point database, denoted by JPS+.
Where applicable we also give results for various combinations of these techiques. These 
variants follow a similar naming pattern.

We begin with Figure~\ref{fig::speedup} which performance results on each of our three
benchmarks in terms of average search time and average nodes expanded. We measure performance
in terms of relative improvement compared with A*. A speedup value of 2 for example indicates 
a two-fold improvement. Under this scheme, higher values are always better.

The results demonstrate the superiority of the approaches presented in this paper.  JPS (B)'s improvement is over one order of magnitude to the point where the additional pruning rule provides only another $10\%$ improvement.  JPS+ (P) gives another order of magnitude; this demonstrates that a substantial amount of time of JPS is spent in finding the next jump point and that any improvement in this direction is beneficial.  

WHY IS IT NOT WORKING SO WELL FOR DRAGON AGE???  

The bottom part of Figure~\ref{fig::speedup} shows a nice correlation 
between the total runtime and the number of nodes expanded.  
Clearly the JPS family's performance 
can be explained by how it quickly identifies 
nodes that can be skipped.  

\begin{figure}[tb]
       \begin{center}
		   \includegraphics[width=0.95\columnwidth, trim = 0mm 0mm 0mm 0mm]
			{diagrams/avg_time_per_node.pdf}
       \end{center}
\caption{Average time, in micro-seconds, to expand a single node. We give a distribution of values showing the performance of each algorithm
on each of our three benchmarks. NB: the range of values along the y-axis differ in each case.}
\label{fig::expansion_time}
\end{figure}

Next, we turn our attention to Figure~\ref{fig::expansion_time} which measures
performance in terms of the average time, in mico-seconds, needed to expand a single node.
It is interesting to observe that in each case the lowest values are attributed to A*. 
JPS (B) and JPS (B+P), which both perform online symmetry breaking, always record
the highest values. These figures are in stark contrast with Figure~\ref{fig::speedup} where
the opposite is true. These results indicate that although eliminating path symmetries can have
a dramatic positive effect on overall search time, individual node expansions can incur a 
significant overhead. Thus, if the start and goal are very close, it is sometimes possible that
A* will be faster than Jump Point Search. The same is also true if JPS must explore very large
empty areas which contain nodes that appear promising but e.g. eventually lead to a dead-end.

Figure~\ref{fig::expansion_time} also provides 
interesting insights for improvement: 
the on-line version of JPS spends substantial time expanding a single node; 
any improvement on this side would result 
in huge performance boost.  
This includes pre-processing techniques lighter 
than JPS+.  

% EOF
