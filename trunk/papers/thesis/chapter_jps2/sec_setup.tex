\section{Experimental Setup}
\label{sec::setup}
We implemented Jump Point Search and a number of variants as described
in this this paper. All source code is written from scratch in C++.
%and is available from {\small \url{http://ddh.googlecode.com}}.
For all our algorithms we have applied a number of simple optimisations 
that help to effectively stride through memory and reduce the effect of 
cache misses.
This means that (i) we store the input map as a vector of bits, one bit 
for each node; (ii) we store the map twice, once in row major order and 
once in column major order; (iii) we pre-allocate memory in 256KB chunks.

We run experiments on a 2010 iMac running OSX 10.6.4. Our machine has 
a 2.93GHz Intel Core 2 Duo processor with 6MB of L2 cache and 4GB of RAM.
For test data we selected three benchmark problem sets taken from
real video games: 
\begin{itemize}
\item \textbf{Dragon Age: Origins}; 44,414 instances across 27 grids of 
sizes ranging 665 to 1.39M nodes.
\item \textbf{Dragon Age 2}; 68,150 instances across 67 grids of sizes 
ranging 1369 to 593K nodes.
\item \textbf{StarCraft}; 29,970 instances across 11 grids of sizes 
ranging 262K to 786K nodes.
\end{itemize}
Instances are sampled from across all possible problem lengths on each map.
All instances have appeared in the 2012 Grid-based Path Planning Competition. 
%
%All maps and test instances are availble from 
%~{\small \url{http://www.movingai.com/benchmarks/}}.
