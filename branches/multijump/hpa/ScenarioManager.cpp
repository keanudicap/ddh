#include "ScenarioManager.h"
#include "aStar3.h"
#include "mapAbstraction.h"

AbstractScenarioManager::~AbstractScenarioManager()
{
	for(unsigned int i=0; i < experiments.size(); i++)
	{
		delete experiments[i];
	}
	experiments.clear();
}

void AbstractScenarioManager::writeScenarioFile(const char* filelocation)
{
	if(experiments.size() == 0) // nothing to write
		return;
	
	std::ofstream scenariofile;
	scenariofile.precision(16);
	scenariofile.open(filelocation, std::ios::out);
	scenariofile << version<<std::endl;

	for(unsigned int i=0; i<experiments.size(); i++)
	{	
		Experiment*	cur = experiments.at(i);
		cur->print(scenariofile);
		scenariofile << std::endl;
	}
	
	scenariofile.close();		
}

ScenarioManager::ScenarioManager()
{
	version = 3.0;
}

ScenarioManager::~ScenarioManager()
{
}

void ScenarioManager::generateExperiments(mapAbstraction* absMap, int numexperiments) 
	throw(TooManyTriesException)
{
	assert(absMap != 0); // need a test here; throw exception if absMap is null
	
	int tries=0;
	int generated=0;
	while(generated < numexperiments)
	{	
		if(tries >= MAXTRIES)
			throw TooManyTriesException(generated, numexperiments);
		
		Experiment* exp = generateSingleExperiment(absMap); 
		if(exp != NULL) 
		{
			this->addExperiment(exp);
			generated++;
		}
		tries++;
	}
}

Experiment* ScenarioManager::generateSingleExperiment(mapAbstraction* absMap)
{
	graph *g = absMap->getAbstractGraph(0);
	const char* _map = absMap->getMap()->getMapName();

	node *r1, *r2;
	Experiment* newexp;

	r1 = r2 = 0;
	path *p=0;

	r1 = g->getRandomNode();
	r2 = g->getRandomNode();

	//ClusterAStar searchalg;
	//searchalg.cardinal = true;
	aStarOld searchalg;
	p = searchalg.getPath(absMap, r1, r2);

	if(!p)
		return NULL;
		
	double dist = absMap->distance(p);
	int x1, x2, y1, y2;
	
	x1 = r1->getLabelL(kFirstData); y1 = r1->getLabelL(kFirstData+1);
	x2 = r2->getLabelL(kFirstData); y2 = r2->getLabelL(kFirstData+1);
	newexp = new Experiment(x1, y1, x2, y2, 1, 1, 0, dist, _map);
	
	delete p;
	return newexp;
}

void ScenarioManager::loadScenarioFile(const char* filelocation)
	throw(std::invalid_argument)
{
	std::ifstream infile;
	infile.open(filelocation,std::ios::in);

	if(!infile.good())
	{
		std::stringstream ss;
		ss << "Invalid scenario file: "<<filelocation;
		throw std::invalid_argument(ss.str());
	}


	// Check if a version number is given
	float version=0;
	string first;
	infile >> first;
	if(first != "version")
	{
		version = 0.0;
		infile.seekg(0,std::ios::beg);
	}

	infile >> version;
	if(version == 1.0 || version == 0)
	{
		loadV1ScenarioFile(infile);
	}
	else if(version == 2.0)
	{
		loadV2ScenarioFile(infile);
	}

	else if(version == 2.1)
	{
		loadV21ScenarioFile(infile);
	}

	else if(version == 3)
	{
		loadV3ScenarioFile(infile);
	}
	else
	{
		std::cout << "Scenario file contains invalid version number. "
			"Exiting\n";
		infile.close();
		exit(-1);
	}

	infile.close();
}

// V1.0 is the version officially supported by HOG
void ScenarioManager::loadV1ScenarioFile(std::ifstream& infile)
{
	int sizeX = 0, sizeY = 0; 
	int bucket;
	string map;  
	int xs, ys, xg, yg;
	double dist;

	while(infile>>bucket>>map>>sizeX>>sizeY>>xs>>ys>>xg>>yg>>dist)
		experiments.push_back(
				new Experiment(xs,ys,xg,yg,sizeX,sizeY,bucket,dist,map));
}

// V2.0 scenario files are generated by AHAScenarioManager; ignore size/capability
void ScenarioManager::loadV21ScenarioFile(std::ifstream& infile)
{
	int xs, ys, xg, yg, capability, agentsize;
	float dist;
	string mapfile;
	while(infile>>mapfile>>xs>>ys>>xg>>yg>>dist>>capability>>agentsize)
		experiments.push_back(
			new Experiment(xs, ys, xg, yg, 1, 1, 0, dist, mapfile));
}

// V2.1 scenario files are generated by AHAScenarioManager; ignore size/capability
void ScenarioManager::loadV2ScenarioFile(std::ifstream& infile)
{
	int xs, ys, xg, yg, capability, agentsize;
	float dist;
	string mapfile;
	while(infile>>mapfile>>xs>>ys>>xg>>yg>>capability>>agentsize>>dist)
		experiments.push_back(
			new Experiment(xs, ys, xg, yg, 1, 1, 0, dist, mapfile));
}

void ScenarioManager::loadV3ScenarioFile(std::ifstream& infile)
{
	int xs, ys, xg, yg;
	float dist;
	string mapfile;
	while(infile>>mapfile>>xs>>ys>>xg>>yg>>dist)
		experiments.push_back(
			new Experiment(xs, ys, xg, yg, 1, 1, 0, dist, mapfile));
}

